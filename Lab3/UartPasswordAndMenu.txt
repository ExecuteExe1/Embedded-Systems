#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "delay.h"
#include "gpio.h"
#include "leds.h"
#include "platform.h"
#include "queue.h"
#include "timer.h"
#include "uart.h"

#define BUFF_SIZE 128 // Read Buffer Length
#define PASSWORD "1234" //our password
#define AEM_LENGTH 8 //Aem

// Additional Define Instructions
unsigned int option=0;
Queue Rx_Queue; // Queue For Storing Received Characters
unsigned int Tick = 0;
uint32_t Current_Index = 0;


	void Menu_SetUp(void){
		uart_print("======Menu=======\r\n");
		uart_print("Options:\r\n");
		uart_print("A.Press 1 for increase of reading and printing frequency by 1s\r\n");
		uart_print("B.Press 2 for decrease of reading and printing frequency by 1s\r\n");
		uart_print("C.Press 3 for change between Temperature/Humidity/or display of both\r\n");
		uart_print("D.Press 4 for print of the latest values and status\r\n");
		uart_print("Insert your desired option: ");
		
		
	}
	
	
	
// Interrupt Service Routine For UART Receive
void UART_Rx_ISR(uint8_t Rx)
{
	// Check If The Received Character Is A Printable ASCII Character
	if ((Rx >= 0x0) && (Rx <= 0x7F))
	{
		// Store The Received Character
		queue_enqueue(&Rx_Queue, Rx);
	}
}

int main(void)
{
	uint8_t Rx_Char = 0;
	char Buff[BUFF_SIZE]; // buffer initialisation
	uint32_t Buff_Index;

	queue_init(&Rx_Queue, 128);
	uart_init(115200);
	uart_set_rx_callback(UART_Rx_ISR);
	uart_enable();

	leds_init();
	leds_set(0, 0, 0);

	__enable_irq();

	while (1)
	{
		//boolean password check
		bool password_correct = false;

		do
		{
			uart_print("Please Enter The Password Please: ");
		
			Buff_Index = 0;

			
			//loop
			do
			{
				while (!queue_dequeue(&Rx_Queue, &Rx_Char))
					__WFI();

				if (Rx_Char == 0x7F) // backspace
				{
					if (Buff_Index > 0)
					{
						Buff_Index--;
						uart_tx('\b');
						uart_tx(' ');
						uart_tx('\b');
					}
				}
				else
				{
					if (Buff_Index < BUFF_SIZE - 1)
					{
						Buff[Buff_Index++] = (char)Rx_Char;
						uart_tx(Rx_Char); 
					}
				}
			} while ((Rx_Char != '\r') && (Buff_Index < BUFF_SIZE));

			  if (Buff_Index > 0 && (Buff[Buff_Index - 1] == '\r' || Buff[Buff_Index - 1] == '\n')) { //it was not accepting the password right so the comparison of the string was not right
             Buff[--Buff_Index] = '\0';                                //so what i did was,check if there was something at the end of the buffer, a \n or \r due to uart {putty,tera}
               } else {                                            //if not puts the end of the string
                        Buff[Buff_Index] = '\0';
                  }
           
    if (strcmp(Buff, PASSWORD) == 0) {
          password_correct = true;
			    uart_print("\r\n");
            //  uart_print("Password Accepted.\r\n");
             } else {
							    	uart_print("\r\n");
         //      uart_print("Wrong Password. Try Again.\r\n\r\n");
             //     }
	          }
					}while(!password_correct);
		
		uart_print("Enter your AEM: ");
		Buff_Index = 0;

		do
		{
			while (!queue_dequeue(&Rx_Queue, &Rx_Char))
				__WFI();

			if (Rx_Char == 0x7F)
			{
				if (Buff_Index > 0)
				{
					Buff_Index--;
					uart_tx('\b');
					uart_tx(' ');
					uart_tx('\b');
				}
			}
			else if (Rx_Char != '\r')
			{
				if (Buff_Index < BUFF_SIZE - 1)
				{
					Buff[Buff_Index++] = (char)Rx_Char;
					uart_tx(Rx_Char);
				}
			}
		} while ((Rx_Char != '\r') && (Buff_Index < AEM_LENGTH));

		Buff[Buff_Index] = '\0';
		uart_print("\r\n");

		uart_print("AEM Received: ");
		uart_print(Buff);
		uart_print("\r\n");
    Menu_SetUp();
		
		
	}

	
}

